// Generated by CoffeeScript 1.6.3
(function() {
  $(function() {
    var format;
    format = function(story, map) {
      _.each(map, function(val, key) {
        if (typeof val !== "function") {
          return story[key] = story[val];
        } else {
          return story[key] = val.call(story);
        }
      });
      return story;
    };
    /* Data Models*/

    window.models.Query = Backbone.Model.extend({
      url: function() {
        return "/queries/" + (this.get("id") || this.get("title"));
      },
      external_url: '/externalNews',
      initialize: function(attrs, options) {
        _.bindAll(this, "getYahooNews", "getGoogleNews", "exists");
        this.map = new window.GoogleMap(this);
        try {
          return this.get("stories").parent_map = options.map;
        } catch (_error) {}
      },
      defaults: function() {
        return {
          stories: new collections.Stories
        };
      },
      parse: function(model) {
        var obj, stories;
        if (model.query != null) {
          obj = model.query;
        } else {
          obj = model;
        }
        this.value = obj.title;
        this.tokens = [obj.title];
        stories = new collections.Stories();
        _.each(obj.stories, function(story) {
          return stories.add(new models.Story(story, {
            parse: true
          }));
        });
        obj.stories = stories;
        if (obj.created != null) {
          obj.created = new Date(obj.created);
        }
        if (obj.last_query != null) {
          obj.last_query = new Date(obj.last_query);
        }
        return obj;
      },
      exists: function(exists_callback, fails_callback) {
        var querytitle, self;
        querytitle = this.get("title");
        self = this;
        $.get("/queries/" + querytitle, {}, function(response) {
          try {
            response = JSON.parse(response);
          } catch (_error) {}
          cc(response);
          if (response.exists !== false && (exists_callback != null)) {
            self.id = response.id;
            self.set("id", response.id);
            console.log(self);
            return exists_callback(querytitle);
          } else if (fails_callback != null) {
            return fails_callback(self, new models.Query(response, {
              parse: true
            }));
          }
        });
        return this;
      },
      favorite: function() {
        var query_id, user_id;
        user.get("queries").add(this);
        user_id = window.user.id;
        query_id = this.id || this.get("id");
        return $.post("/favorite", {
          user_id: user_id,
          query_id: query_id
        }, function(resp) {
          resp = JSON.parse(resp);
          cc(resp);
          return cc("THIS MAP HAS BEEN FAVORITED");
        });
      },
      addStory: function(story, opts) {
        var id, options, stories, title;
        stories = this.get("stories");
        title = story.title.toLowerCase().stripHTML();
        if (!stories._byTitle.hasOwnProperty(title)) {
          cc("adding story");
          options = _.extend({}, opts);
          stories.add(story = new models.Story(format(story, options.map)), options);
          id = this.get("id") || this.id;
          if (id) {
            story.set("query_id", id);
          }
          stories._byTitle[title] = story;
        } else {
          cc("story exists");
        }
        return this;
      },
      getGoogleNews: function(start, done) {
        var query, self;
        self = this;
        query = this.get("title");
        start || (start = 0);
        $.get(this.external_url, {
          source: 'google',
          q: query.toLowerCase(),
          start: start
        }, function(response) {
          console.count("google news story set returned");
          try {
            response = JSON.parse(response);
            console.log(response);
            if (response.responseDetails === "out of range start" || response.responseDetails === "Invalid start" || start > 64) {
              if (done != null) {
                console.log(done);
                done(0, null);
              }
            }
            _.each(response.responseData.results, function(story) {
              return self.addStory(story, {
                map: {
                  date: function() {
                    return new Date(this['publishedDate']);
                  },
                  aggregator: function() {
                    return 'google';
                  },
                  url: 'unescapedUrl'
                }
              });
            });
            if (start < 64) {
              return self.getGoogleNews(start + 32, done);
            }
          } catch (_error) {}
        });
        return this;
      },
      getYahooNews: function(start, done) {
        var query, self;
        query = '"' + this.get("title").toLowerCase() + '"';
        start || (start = 0);
        self = this;
        $.get(this.external_url, {
          source: 'yahoo',
          q: query,
          start: start
        }, function(response) {
          var news, stories, total;
          response = JSON.parse(response);
          try {
            console.count("yahoo news story set returned");
            news = response.bossresponse.news;
            stories = news.results;
            total = 200;
            _.each(stories, function(story) {
              return self.addStory(story, {
                map: {
                  content: 'abstract',
                  date: function() {
                    return new Date(parseInt(story.date) * 1000);
                  },
                  aggregator: function() {
                    return 'yahoo';
                  },
                  'publisher': 'source'
                }
              });
            });
            if (start <= total) {
              return self.getYahooNews(start + 50, done);
            } else if (done != null) {
              console.log(done);
              return done(0, null);
            }
          } catch (_error) {
            if (done != null) {
              console.log(done);
              return done(0, null);
            }
          }
        });
        return this;
      }
    });
    window.collections.Queries = Backbone.Collection.extend({
      model: models.Query,
      url: "/queries",
      parse: function(response) {
        cc(response.queries[0]);
        cc("parsing collection");
        return response.queries;
      }
    });
    window.models.Story = Backbone.Model.extend({
      url: function() {
        var url;
        url = "/stories";
        if (this.id) {
          url += "/" + this.id;
        }
        return url;
      },
      geocodeUrl: 'http://maps.googleapis.com/maps/api/geocode/json?sensor=true&address=',
      loading: false,
      defaults: {
        hasLoaded: false
      },
      initialize: function() {
        _.bindAll(this, "geocode");
        return this.on({
          "loading": function() {
            return this.loading = true;
          },
          "doneloading": function() {
            return this.loading = false;
          },
          "change:hasLocation": function(model, value) {
            if (value === true) {
              this.collection._withLocation[this.get("title")] = this;
              return console.log(this.collection);
            }
          }
        });
      },
      attach: function(objects, plot) {
        var self;
        self = this;
        this.trigger("loading");
        _.each(objects, function(obj) {
          var applyfun, i;
          applyfun = obj.applyfun;
          if (applyfun != null) {
            for (i in obj) {
              cc(i);
              if (obj[i] !== applyfun) {
                obj[i] = applyfun.apply(self, [obj[i]]);
              }
            }
          }
          return _.extend(self.attributes, obj);
        });
        if (plot === true) {
          this.plot();
        }
        return this;
      },
      hasLocation: function() {
        return (this.get("lat") != null) && this.get("lng");
      },
      getCalaisData: function(callback) {
        var j, self, story_string;
        self = this;
        try {
          j = this.toJSON();
          story_string = j.title + j.content;
        } catch (_error) {
          return console.error("Badly formatted model passed to calais");
        }
        $.get("/calais", {
          content: story_string
        }, function(calaisjson) {
          if (!(calaisjson == null)) {
            console.count("calais data returned for " + j.title);
            return self.parseCalais(calaisjson, {
              plot: true
            });
          }
        });
        return this;
      },
      parseCalais: function(json, opts) {
        var options, self;
        options = _.extend({
          plot: true
        }, opts);
        self = this;
        return _.each(json.entities, function(entity) {
          var breakval;
          if (entity.hasOwnProperty("resolutions")) {
            console.log(entity);
            breakval = true;
            _.each(entity.resolutions, function(coords) {
              if ((coords.latitude != null) && (coords.longitude != null)) {
                self.set("location", coords.name);
                self.attach([
                  {
                    applyfun: parseFloat,
                    lat: coords.latitude,
                    lng: coords.longitude
                  }
                ], options.plot);
                self.set("hasLocation", true);
                return breakval = false;
              }
              return true;
            });
            return breakval;
          }
        });
      },
      plot: function() {
        window.mapObj.plot(this);
        return this;
      },
      geocode: function(address, callback) {
        var self;
        self = this;
        console.log(self);
        $.getJSON(this.geocodeUrl + encodeURIComponent(address), function(response) {
          var coords;
          try {
            coords = response.results[0].geometry.location;
            self.save({
              lat: coords.lat,
              lng: coords.lng,
              location: response.results[0].formatted_address
            }, {
              success: function(model, resp) {
                console.log(model);
                self.set("hasLocation", true);
                self.plot();
                return console.log(resp);
              },
              error: function(model, resp) {
                console.log(model);
                return console.log(resp);
              }
            });
            if (callback != null) {
              return callback(true, coords);
            }
          } catch (_error) {
            console.log(_error);
            if (callback != null) {
              return callback(false, null);
            }
          }
        });
        return this;
      }
    });
    return (function() {
      var sortMethods;
      sortMethods = {
        "newest": function(story) {
          return story.get("date");
        },
        "oldest": function() {
          return -story.get("date");
        }
      };
      return window.collections.Stories = Backbone.Collection.extend({
        model: models.Story,
        _byTitle: {},
        _withLocation: {},
        initialize: function(opts) {
          if ((opts != null) && opts.parent_map) {
            this.parent_map = opts.parent_map;
          }
          this._byTitle = {};
          return this;
        },
        filterByDate: function(lodate, hidate) {
          var inrange, outrange, self;
          self = this;
          inrange = [];
          outrange = [];
          _.each(this.models, function(story) {
            var date, marker, markerObj;
            date = story.get("date");
            if (date instanceof Date === false) {
              story.set("date", new Date(date));
            }
            markerObj = story.marker;
            if (markerObj != null) {
              marker = markerObj.marker;
              if (date < hidate && date > lodate) {
                return inrange.push(marker);
              } else {
                return outrange.push(marker);
              }
            }
          });
          return {
            inrange: inrange,
            outrange: outrange
          };
        }
      });
    })();
  });

}).call(this);
